# TSN Configuration File Formats

This document specifies the JSON file formats used by the TSN (Time-Sensitive Networking) configuration and analysis tool. These formats are designed to be:

*   **Human-Readable:** Easy to understand and edit manually.
*   **Machine-Parsable:** Easily processed by Python tools (and other languages).
*   **Extensible:** Able to accommodate new features and parameters without major structural changes.
*   **Concise:** Avoid redundant information.

The TSN tools use three primary input files:

1.  `topology.json`: Describes the network topology (nodes and links).
2.  `streams.json`: Describes the traffic flows (streams) in the network.
3.  `routes.json`:  *(Optional)* Specifies pre-computed routes for flows. If this file is not provided, or if a flow is not listed in this file, the tool will compute the route.
4.  `schedules.json`: Describes the frame transmission schedule for each link in the network.
5.  `gcls.json`: Describes the Gate Control Lists (GCLs) for each port of each switch and end-system in the network.


The test case generator uses:

4. `gen_config.json` : used by the test case generator tool to produce the other input files.

Note: The `schedules.json` and `gcls.json` files are outputs from a separate scheduling tool and not generated by this generator tool.

## Network Topology (`topology.json`)

This file defines the network topology, including end systems (ES), switches (SW), and the unidirectional links connecting them.

```json
{
  "topology": {
    "default_bandwidth_mbps": 1000,
    "delay_units": "MILLI_SECOND",
    "switches": [
      { "id": "SW0", "ports": 8, "domain": 0 },
      { "id": "SW1", "ports": 6, "domain": 0 }
    ],
    "end_systems": [
      { "id": "ES0", "domain": 0 },
      { "id": "ES1", "domain": 0 }
    ],
    "links": [
      { "id": "Link1", "source": "SW1", "sourcePort": 0,
        "destination": "SW10", "destinationPort": 0,
        "bandwidth_mbps": 1000, "delay": 0.1, "domain": 0 },
      { "id": "Link4", "source": "SW1", "sourcePort": 4,
        "destination": "ES10", "destinationPort": 0,
        "delay": 0.1, "domain": 0 }
    ]
  }
}
```

**Top-Level Structure:**

*   **`topology`**:  The root object.
    *   **`default_bandwidth_mbps`** (number, optional):  The default bandwidth for all links in the network, in Mbps.  If a link specifies its own `bandwidth_mbps`, it overrides this default.  If omitted, a default value of 1000 Mbps (1 Gbps) is assumed by the tool.  This provides a convenient way to set a common bandwidth without repeating it for every link.
    *   **`delay_units`** (string, optional): Specifies the time units for all delay values in the file. Common values are "MILLI_SECOND", "MICRO_SECOND", "NANO_SECOND", etc. If omitted, defaults to "MILLI_SECOND".
    *   **`switches`**: An array of switch objects.
    *   **`end_systems`**: An array of end system objects.
    *   **`links`**: An array of link objects.
    *   If you want a full duplex connection between two nodes, create two link objects, one in each direction.

**Switch Object:**

| Field      | Type    | Description                                                           |
|------------|---------|-----------------------------------------------------------------------|
| `id`       | string  | Unique identifier for the switch (e.g., "SW2"). |
| `ports`    | integer | Number of ports on the switch.                                         |
| `domain`   | integer | The ID of the TSN domain this switch belongs to. |

**End System Object:**

| Field      | Type    | Description                                                           |
|------------|---------|-----------------------------------------------------------------------|
| `id`       | string  | Unique identifier for the end system (e.g., "ES3"). |
| `domain`   | integer | The ID of the TSN domain this end system belongs to.  |

**Link Object:**

| Field             | Type    | Description                                                           |
|-------------------|---------|-----------------------------------------------------------------------|
| `id`              | string  | Unique identifier for the link (e.g., "Link1").                       |
| `source`          | string  | The `id` of the source node.                                         |
| `sourcePort`    | integer   | The port number on the source device. For end systems, always use port 0. |
| `destination`     | string  | The `id` of the destination node.                                     |
| `destinationPort` | integer   | The port number on the destination device. For end systems, always use port 0. |
| `bandwidth_mbps`  | number, optional  | Bandwidth of the link in Mbps. Overrides `default_bandwidth_mbps`. |
| `delay`       | double, optional  | Link delay (propagation delay) in the units specified by `delay_units`. Defaults to 0. |
| `domain`   | integer | The domain ID for this link. For cross-domain links, use the domain of the source node. |
| `utilization`    | double       | Link utilization percentage.  This is an *output* of the scheduling process, not an input. This value will be computed and saved to a different file. |

**Design Decisions and Motivations (Topology):**

*   **Separated Arrays:** Switches and end systems are now in separate arrays, making the structure clearer and removing the need for a "type" field.
*   **Naming Convention:** Component IDs follow a format of "TYPE<counter>", e.g., "SW1", "ES2".
*   **Unidirectional Links:**  Links are explicitly unidirectional.  For bidirectional communication, two link entries are required (A->B and B->A).  This simplifies path calculations and makes the representation more consistent with how TSN works at the physical layer. It avoids any ambiguity.
*   **End System Ports:** End systems are always considered single-port devices and should use port 0.
*   **No MAC Addresses:** MAC addresses are not relevant for the core scheduling and routing algorithms.  They are removed to simplify the input.
*	**Domain Identification:** The domain is indicated by an explicit `domain` field. For cross-domain links, the domain field is set to the source node's domain.

## Streams (`streams.json`)

This file defines the TSN flows (streams) in the network, including their timing requirements and source/destination information.

```json
{
  "delay_units": "MILLI_SECOND",
  "streams": [
    {
      "id": 0,
      "name": "Stream_1",
      "source": "node0_80_1",
      "destinations": [
        {"id": "node0_68_1", "deadline": 13}
      ],
      "type": "ISOCHRONOUS",
      "PCP": 7,
      "size": 94,
      "period": 2,
      "redundancy": 0
    },
    {
      "id": 150,
      "name": "Stream_150",
      "source": "node0_103",
      "destinations": [
        {"id": "node0_126_1", "deadline": 8},
        {"id": "node0_12", "deadline": 12}
      ],
      "type": "CYCLIC-ASYNCHRONOUS",
      "PCP": 4,
      "size": 1434,
      "period": 10,
      "redundancy": 0
    }
  ]
}
```

**Fields:**

*   **`delay_units`** (string, optional): Specifies the time units for all time values in the file. Common values are "MILLI_SECOND", "MICRO_SECOND", "NANO_SECOND", etc. If omitted, defaults to "MILLI_SECOND".
*   **`streams`**: An array of stream objects. Each object represents a single flow.

    *   **`id`** (integer): Unique identifier for the stream. Must be an integer.
    *   **`name`** (string): A descriptive name for the stream (for human readability).
    *   **`source`** (string): The `id` of the source node (End System).
    *   **`destinations`** (array of objects): A list of destination objects, each containing:
        *   **`id`** (string): The `id` of the destination node (End System).
        *   **`deadline`** (number): The relative deadline for this specific destination, in the units specified by `delay_units`. This is relative to the stream's period.
    *   **`type`** (string): The traffic type of the stream. Common values include "ISOCHRONOUS" and "CYCLIC-ASYNCHRONOUS".
    *   **`PCP`** (integer):  The Priority Code Point (PCP) value (0-7).
    *   **`size`** (number): The size of the stream's packets, in *bytes*.
    *   **`period`** (number): The period of the stream, in the units specified by `delay_units`.
    *   **`redundancy`** (integer): The number of redundant paths required for this flow. Set to 0 when no redundancy is needed, or higher values (such as 2) for multiple redundant paths.

**Changes and Motivations:**

*   **Integer `id`:**  Using integers for the stream ID simplifies processing and indexing.
*   **`destinations` (array of objects):**  Using an array of destination objects with `id` and `deadline` properties supports multicast flows with destination-specific deadlines.
*   **Units:** Time units are specified by the `delay_units` field.
*   **Traffic Types:** The traffic types used should match those from the generator (e.g., "ISOCHRONOUS" or "CYCLIC-ASYNCHRONOUS").
*   **Redundancy:** Set to 0 for streams with no redundant paths.

## Routes (`routes.json`)

This file *optionally* provides pre-computed routes for flows.  If a route is not specified for a flow in this file, the scheduler will attempt to find a route.  This file is primarily used for:

1.  Providing an initial solution to the scheduler.
2.  Fixing the route of certain flows, preventing the scheduler from changing them.

```json
{
  "delay_units": "MICRO_SECOND",
  "routes": [
    {
      "flow_id": 0,
      "paths": [
        [
          {"node": "node0_80_1", "port": 0},
          {"node": "sw_1", "port": 0},
          {"node": "sw_2", "port": 0},
          {"node": "sw_3", "port": 0},
          {"node": "node0_68_1", "port": 0}
        ]
      ],
      "min_e2e_delay": 0.2
    },
    {
      "flow_id": 150,
      "paths": [
        [
          {"node": "node0_103", "port": 0},
          {"node": "sw_37", "port": 7},
          {"node": "sw_41", "port": 0},
          {"node": "sw_42", "port": 1},
          {"node": "sw_43", "port": 2},
          {"node": "sw_44", "port": 4},
          {"node": "sw_52", "port": 2},
          {"node": "sw_53", "port": 0},
          {"node": "node0_126_1", "port": 0}
        ],
        [
          {"node": "node0_103", "port": 0},
          {"node": "sw_37", "port": 6},
          {"node": "sw_38", "port": 0},
          {"node": "sw_45", "port": 2},
          {"node": "sw_46", "port": 1},
          {"node": "sw_47", "port": 0},
          {"node": "sw_55", "port": 3},
          {"node": "node0_12", "port": 0}
        ]      
      ],
      "min_e2e_delay": 200
    }
  ]
}
```

**Fields:**

*   **`delay_units`** (string, optional): Specifies the time units for all time values in the file. Common values are "MICRO_SECOND", "NANO_SECOND", etc. If omitted, defaults to "MICRO_SECOND".
*   **`routes`**: An array of route objects, one for each flow.
*   **`flow_id`** (integer): The integer ID of the flow (matches `streams.json`).
*   **`paths`**: An array of paths. Each path is an array of hops. If a stream has `redundancy > 0`, you can list multiple `paths` arrays for that flow ID. Each hop is an object with:
    *   `node`: The `id` of the node.
    *   `port`: The egress port number on that node. For end systems, always use port 0.
*    **`min_e2e_delay`**: (Optional) The minimum end-to-end delay for this flow, considering the shortest possible path, in the units specified by `delay_units`.

**Changes and Motivations:**

* **Integer `flow_id`**: Consistent with `streams.json`.
* **`paths` Array:** Supports multiple paths for redundancy or for streams that are multicast.
* **End System Ports:** End systems always use port 0.
* **`min_e2e_delay`**: Values use the units specified by `delay_units`.

**Note:** Domains and redundancy are both optional features. The file format can handle single-domain or multi-domain networks, and single-route or redundant-route streams.

## Test Case Generator Configuration (`gen_config.json`)

This file configures the test case generator that creates the `topology.json` and `streams.json` files (and optionally `routes.json` if needed). It lets you specify how many separate test cases to generate, how large each topology is, and how many streams to create.

```json
{
  "delay_units": "MICRO_SECOND",
  "general": {
    "output_directory": "test-cases",
    "num_test_cases": 3,
    "num_domains": 2,
    "topology_size": {
      "num_switches": 10,
      "num_end_systems": 20,
      "end_systems_per_switch": [0, 4]
    },
    "cross_domain_streams": 5,
    "generate_routes": true,
    "test_case_naming": "test_case_{}"
  },
  "network": {
    "topology_type": "mesh_graph",
    "parameters": "{'n': 4, 'm': 4}",
    "default_bandwidth_mbps": 1000,
    "constraints": {
      "max_path_length": 5,
      "min_redundant_paths": 2
    }
  },
  "domain_connections": {
    "type": "line",
    "connections_per_domain_pair": 2
  },
  "routing": {
    "algorithm": "shortest_path",
    "consider_link_utilization": true
  },
  "traffic": {
    "types": [
      {
        "name": "ISOCHRONOUS",
        "PCP-list": [7],
        "number": 50,
        "redundant_number": 5,
        "redundant_routes": 2,
        "cycle_time": {
            "cycle_time_units": "MICRO_SECOND",
            "choose_list": true,
            "cycle_time_list": [
               1000,
               2000
            ],
            "min_cycle_time": 500,
            "max_cycle_time": 2000
        },
        "min_delay": 500,
        "max_delay": 1000,
        "min_packet_size": 30,
        "max_packet_size": 100,
        "bidirectional": false
      },
      {
        "name": "VIDEO",
        "PCP-list": [4],
        "number": 50,
        "redundant_number": 0,
        "redundant_routes": 0,
        "cycle_time": {
            "cycle_time_units": "MICRO_SECOND",
            "choose_list": true,
            "cycle_time_list": [
               2000,
               10000,
               20000
            ],
            "min_cycle_time": 500000,
            "max_cycle_time": 2000000
        },
        "min_delay": 500000,
        "max_delay": 2000000,
        "min_packet_size": 500,
        "max_packet_size": 1500,
        "bidirectional": false
      }
    ]
  }
}
```

### Top-Level Fields

- **`delay_units`**: Default time unit for generated streams and topology delays. Common values: `"MILLI_SECOND"`, `"MICRO_SECOND"`, etc.
- **`general`**:  
  - **`output_directory`**: Folder for generated output files.  
  - **`num_test_cases`** (integer): Number of test cases to generate. Each test case will produce a separate set of files (e.g., `topology.json`, `streams.json`).  
  - **`num_domains`** (integer): Number of TSN domains to generate (for multi-domain scenarios).  
  - **`topology_size`** (object): Describes how big the topology is, e.g.:
    - **`num_switches`** (integer): Number of switches in each domain.  
    - **`num_end_systems`** (integer): Total number of end systems in the network.
    - **`end_systems_per_switch`** (array): Range of end systems per switch, specified as [min, max]. The actual number is randomly determined within this range, while respecting the total number of end systems.
  - **`test_case_naming`** (string): Pattern for naming test case directories, using Python string formatting. Example: `"test_case_{}"` will generate directories like `test_case_1`, `test_case_2`, etc.
  - **`cross_domain_streams`** (integer): Number of streams that cross domain boundaries (only applicable for multi-domain scenarios).
  - **`generate_routes`** (boolean): Whether to generate the routes.json file for each test case.

### Network Section

*   **`network`**:
    *   **`topology_type`**: The type of topology to generate (e.g., "mesh_graph", "tree", "binomial_graph", "industrial_ring_topology").  This string will be passed to `networkx`.  See [NetworkX documentation](https://networkx.org/documentation/stable/reference/generators.html) for a complete list of generators.
    *   **`parameters`**:  A JSON string representing the parameters to pass to the `networkx` graph generator function.  Example: `"{'n': 4, 'm': 4}"` for a `grid_2d_graph(n, m)`. This must be valid JSON.
    *   **`default_bandwidth_mbps`** (number): Default bandwidth for all links in the network, in Mbps.
    *   **`constraints`** (object, optional): Additional constraints for the network topology:
        *   **`max_path_length`** (integer, optional): Maximum number of hops allowed between any two nodes in the network.
        *   **`min_redundant_paths`** (integer, optional): Minimum number of independent paths required between critical nodes.

**Note on topology types and node counts:**
- For structured topologies (mesh_graph, tree, ring), the switch count is determined by the topology parameters, and the `num_switches` parameter in `topology_size` is ignored.
- For example, a mesh_graph with parameters `{'n': 4, 'm': 4}` will create exactly 16 switches regardless of the specified `num_switches` value.
- For less structured or random topologies, the `num_switches` parameter is used to determine the exact number of switches to create.
- The `num_end_systems` parameter is always respected and determines how many end systems to generate.

**Examples of `parameters` strings (depending on `topology_type`):**
- **`"mesh_graph"`**  
  - `parameters`: `"{'n': 4, 'm': 4}"` (creates a 4×4 2D grid of 16 switches).
- **`"tree"`**
  - `parameters`: `"{'depth': 3, 'branching_factor': 2, 'redundancy': 1}"` (creates a tree with 3 levels, each node having 2 children, with redundant links for fault tolerance).
- **`"binomial_graph"`**  
  - `parameters`: `"{'p': 0.1}"` (probability of edge creation is 0.1).
- **`"industrial_ring_topology"`**  
  - `parameters`: `"{'num_rings': 4}"` (an industrial ring with 4 rings; the rings will be connected with each other).
- **`"random_geometric_graph"`**  
  - `parameters`: `"{'r': 0.2}"`.

**Topology Size and Parameters Relationship:**
1. For **mesh_graph** with `{'n': 4, 'm': 4}`, exactly 16 switches will be created (4×4 grid)
2. For **tree** with `{'depth': 3, 'branching_factor': 2}`, switches are determined by the formula: sum(branching_factor^level) for levels 0 to depth-1
3. For **industrial_ring_topology** with `{'num_rings': 4}`, the number of switches is determined by the ring structure
4. For random topologies like **binomial_graph**, the `num_switches` parameter is used to set the exact number of switches

**Note:** All generated topologies must be connected, meaning there are no isolated nodes or components. The generator should ensure that all nodes are reachable from each other.

### Domain Connections

- **`domain_connections`**:
  - **`type`** (string): How domains connect to each other (e.g., `"line"`, `"square"`, `"random"`).
  - **`connections_per_domain_pair`** (integer): Number of inter-domain links to create between each connected pair of domains.

### Routing Section

- **`routing`**:
  - **`algorithm`** (string): Routing algorithm to use (e.g., "shortest_path").
  - **`consider_link_utilization`** (boolean): Whether to consider link utilization for balanced routing.

### Traffic Configuration

- **`traffic`**:
  - **`types`** (array of traffic definitions):
    - **`name`** (string): Name of the traffic type (e.g., `"ISOCHRONOUS"`, `"VIDEO"`).
    - **`PCP-list`** (array): Allowed priority code points.
    - **`number`** (integer): How many streams of this traffic type to create.
    - **`redundant_number`** (integer): How many of these streams require redundancy.  
    - **`redundant_routes`** (integer): Number of parallel paths for those redundant streams.
    - **`cycle_time`** (object): Describes the range or list of valid periods considering the units in **`delay_units`**:
      - **`choose_list`** (boolean): If `true`, pick from `cycle_time_list`; else use `min_cycle_time` to `max_cycle_time`.
      - **`cycle_time_list`** (array): Possible discrete period values.
      - **`min_cycle_time`**, **`max_cycle_time`** (integers): Bounds for random period selection.
    - **`min_delay`**, **`max_delay`** (integers): Deadline range.
    - **`min_packet_size`**, **`max_packet_size`** (integers): Packet size range in bytes.
    - **`bidirectional`** (boolean): If `true`, generate each flow in both directions.

### Notes

- `redundancy = 0` means no redundant paths.
- If `"delay_units"` is `"MILLI_SECOND"`, do not suffix times with "_ms"; the script already knows the unit.
- When `num_domains > 1`, each domain will have its own sub-topology, and domain interconnections can be specified in `"domain_connections"`.
- If `"num_test_cases"` is given as 2 (for example), the tool will generate two sets of JSON files, each with a different randomly generated topology and streams (unless a fixed seed is used).
- By adjusting `"topology_size"`, `"network"`, and `"traffic"`, you can control how large the resulting files are and how many streams exist in each test case.
- The `test_case_naming` pattern determines how test case directories are named. Use Python's string formatting syntax with `{}` as a placeholder for the test case number.
-   **JSON Format:** Using JSON for consistency with other configuration files.
-   **Clearer Structure:** Grouped parameters logically.
-   **Topology Type and Parameters:**  This allows using *any* NetworkX graph generator, providing maximum flexibility.
-   **`domain-connections`**:  Moved the multi-domain connection type to its own top-level key for clarity.
-   Note that several PCP values can be listed in a PCP-list. The test case generator tool should generate a random PCP value from the list. The mapping of PCP values to queues is captured in a separate switch configuration file.

## Schedules (`schedules.json`)

This file defines the frame transmission schedule for each link in the network. It describes when each frame of each stream is scheduled to be transmitted on a specific link.

```json
{
  "delay_units": "MICRO_SECOND",
  "schedules": [
    {
      "link_id": "e1",
      "schedule_entries": [
        {
          "stream_id": 0,
          "frame_instance": 1,
          "offset": 0,
          "duration": 12.336
        },
        {
          "stream_id": 1,
          "frame_instance": 1,
          "offset": 18,
          "duration": 12.336
        },
        {
          "stream_id": 1,
          "frame_instance": 2,
          "offset": 31,
          "duration": 12.336
        },
        {
          "stream_id": 1,
          "frame_instance": 3,
          "offset": 44,
          "duration": 12.336
        }
      ]
    },
    {
      "link_id": "e2",
      "schedule_entries": [
        {
          "stream_id": 2,
          "frame_instance": 1,
          "offset": 0,
          "duration": 12.336
        }
      ]
    }
  ]
}
```

**Fields:**

*   **`delay_units`** (string, optional): Specifies the time units for all time values in the file. Common values are "MICRO_SECOND", "NANO_SECOND", etc. If omitted, defaults to "MICRO_SECOND".
*   **`schedules`**: An array of schedule objects. Each object represents the schedule for a specific link in the network.

    *   **`link_id`** (string): The `id` of the link to which this schedule applies. Must match a link `id` in `topology.json`.
    *   **`schedule_entries`** (array of objects): An array of schedule entries, ordered by `offset`. Each entry defines the transmission of a frame.

        *   **`stream_id`** (integer): The `id` of the stream to which this frame belongs. Must match a stream `id` in `streams.json`.
        *   **`frame_instance`** (integer): The instance number of the frame within the stream's period (e.g., 1, 2, 3... if a stream sends multiple frames per period). Starts from 1.
        *   **`offset`** (number): The start time (offset) of the frame transmission on the link, in the units specified by `delay_units`, relative to the beginning of the schedule cycle (or hyperperiod).
        *   **`duration`** (number): The duration of the frame transmission on the link, in the units specified by `delay_units`.

**Changes and Motivations (Schedules):**

*   **JSON Format:** Consistent JSON format.
*   **`link_id`**:  Clearly identifies the link for which the schedule is defined.
*   **`schedule_entries` array**:  An ordered list of schedule entries, allowing to represent the sequence of frame transmissions on a link.
*   **`stream_id` and `frame_instance`**:  Precisely identifies which frame of which stream is being scheduled. `frame_instance` is important for streams that are segmented into multiple frames per period.
*   **`offset` and `duration`**: Defines the timing of frame transmission in the units specified by `delay_units`.

**Simplifications and Clarifications:**

*   **No Queue Information (in Schedule):** The schedule format, as requested, focuses on *when* frames are transmitted on links. Queue assignments are typically determined during the scheduling process and can be visualized separately (e.g., using colors to represent queues).  If queue-specific scheduling visualization is required, the format could be extended to include queue information per schedule entry.
*   **Time Units in `delay_units`**: Using a common unit specification for time values provides sufficient precision for most network configurations.
*   **Isolated Streams and GCLs/Schedules Correspondence**: In scenarios with "isolated streams" (where each stream is carefully scheduled to avoid interference), there will be a direct correspondence between the GCL entries and the frame schedule. Specifically, a TSN window in the GCL will correspond to the transmission of one or more frames within that time interval. However, in more complex scenarios with interleaved streams or non-isolated configurations, this direct correspondence might not always be present. The GCL dictates *when* and for *which priorities* the gates are open, while the schedule dictates *which frames* are transmitted *when*. The GCL enables the schedule, but the schedule is a higher-level abstraction representing the planned frame transmissions.

## Gate Control Lists (`gcls.json`)

This section describes the JSON file format for Gate Control Lists (`gcls.json`), used to define Time-Aware Shaper (TAS) configurations in Time-Sensitive Networks (TSN). This format is designed to be general and capture the essential elements of GCLs as described in TSN standards and literature, including concepts like guard bands and time windows relevant to preemption, without being tied to specific vendor implementations or documents.

```json
{
  "delay_units": "NANO_SECOND",
  "gcls": [
    {
      "node_id": "sw",
      "port_id": 0,
      "cycle_time": 200,
      "entries": [
        {
          "index": 0,
          "gate_states": 0,  // Guard Band State
          "time_interval": 114
        },
        {
          "index": 1,
          "gate_states": 128, // TSN Traffic Window State
          "time_interval": 886
        },
        {
          "index": 2,
          "gate_states": 0,  // Guard Band State
          "time_interval": 114
        },
        {
          "index": 3,
          "gate_states": 128, // TSN Traffic Window State
          "time_interval": 886
        },
        {
          "index": 4,
          "gate_states": 127, // Non-TSN Traffic Window State
          "time_interval": 114
        },
        {
          "index": 5,
          "gate_states": 0,  // Guard Band State
          "time_interval": 114
        },
        {
          "index": 6,
          "gate_states": 128, // TSN Traffic Window State
          "time_interval": 1234
        },
        {
          "index": 7,
          "gate_states": 127, // Non-TSN Traffic Window State
          "time_interval": 114
        },
        {
          "index": 8,
          "gate_states": 0,  // Guard Band State
          "time_interval": 98652
        }
      ]
    },
    {
      "node_id": "es",
      "port_id": 0,
      "cycle_time": 200,
      "entries": [
        {
          "index": 0,
          "gate_states": 128, // TSN Traffic Window State
          "time_interval": 200000
        }
      ]
    }
  ]
}
```

**Fields:**

*   **`delay_units`** (string, optional): Specifies the time units for all time values in the file. Common values are "MICRO_SECOND", "NANO_SECOND", etc. If omitted, defaults to "NANO_SECOND" for GCL files since they often need finer granularity.
*   **`gcls`**: An array of GCL objects. Each object defines the Gate Control List for a specific port of a network device.

    *   **`node_id`** (string):  The identifier of the network node (switch or end-system) where this GCL is configured. This ID must correspond to a `node_id` defined in your `topology.json` file.
    *   **`port_id`** (integer): The port number on the specified `node_id` to which this GCL applies. GCLs are configured on egress ports to control outgoing traffic.
    *   **`cycle_time`** (number): The duration of one complete GCL cycle, in the units specified by `delay_units`. The GCL entries will repeat in this cycle. This value defines the periodic nature of the Time-Aware Shaper.
    *   **`entries`** (array of objects): An ordered list of Gate Control Entries that constitute the GCL. The entries are executed sequentially based on their `index` within each `cycle_time`.

        *   **`index`** (integer): The position of this entry within the GCL sequence. Entries are processed in ascending order of their index, starting from 0.
        *   **`gate_states`** (integer):  Defines the state of the egress port's gates for different traffic priorities during the specified `time_interval`. This integer value represents a pre-defined gate state configuration. Common gate states and their general interpretations in a TSN context are:

            *   **`0` (Guard Band State):**  Represents a **Guard Band**. In this state, all gates controlled by the GCL are closed, preventing the transmission of both TSN (time-sensitive) and non-TSN traffic from the queues managed by the GCL on this port. Guard bands are essential to create temporal separation and prevent lower priority traffic from interfering with time-critical transmissions.

            *   **`128` (TSN Traffic Window State):** Represents a **Time-Sensitive Networking (TSN) Traffic Window**.  In this state, the gate for the **highest priority TSN queue is opened**, allowing time-critical traffic to be transmitted with minimal latency and jitter. Gates for lower priority queues (typically used for non-TSN or best-effort traffic) are closed during this window to ensure priority for TSN streams.

            *   **`127` (Non-TSN Traffic Window State):** Represents a **Non-TSN Traffic Window**. In this state, gates are opened for **lower priority queues**, typically used for best-effort traffic or non-time-sensitive data.  The gate for the **highest priority TSN queue is closed**, preventing TSN traffic transmission and allowing non-TSN traffic to be served without interference from time-critical streams.

            *   **Other values:**  Depending on the specific TSN implementation and hardware capabilities, other integer values for `gate_states` might be defined to represent different combinations of gate opening/closing for various priority levels. Refer to the device documentation for a complete mapping of `gate_states` values if needed.

        *   **`time_interval`** (number): Specifies the duration, in the units specified by `delay_units`, for which the `gate_states` setting is active. This value determines the length of the time segment for each GCL entry.

**Understanding Gate States, Guard Bands, and Preemption in GCLs**

*   **Gate Control Lists and Time-Aware Shaping (TAS):** GCLs are the core mechanism for implementing Time-Aware Shaping (TAS) as defined in IEEE 802.1Qbv. They enable precise control over traffic transmission by opening and closing gates for different priority queues based on a time schedule.

*   **Guard Bands for Temporal Isolation:** Guard Bands, represented by the `gate_states: 0` state, are critical for achieving deterministic communication in TSN. By creating periods where all GCL-controlled gates are closed, they ensure that time-sensitive traffic is not interfered with by lower priority traffic.  They provide temporal isolation between different traffic types.

*   **TSN and Non-TSN Windows for Traffic Prioritization:** TSN Traffic Windows (`gate_states: 128`) and Non-TSN Traffic Windows (`gate_states: 127`) define distinct time segments within the GCL cycle dedicated to different traffic types. This allows for prioritizing time-critical TSN traffic while still accommodating best-effort or non-time-sensitive traffic on the same network infrastructure.

*   **Preemption - An Enhancement (Not Directly in GCL):** Frame preemption (IEEE 802.1Qbu) is a separate TSN mechanism that can work in conjunction with TAS (GCLs). Preemption is designed to further minimize latency and improve bandwidth utilization.  While GCLs define the overall time windows for different traffic types, preemption, if enabled, can operate *within* those TSN windows.  Preemption allows a high-priority frame to interrupt a lower-priority frame transmission within a TSN window, providing even finer-grained control over latency.  **It's important to note that the `gate_states` in `gcls.json` primarily represent the TAS/Qbv (GCL) configuration itself.  Preemption settings are typically configured separately at a lower level in TSN devices and are not directly represented within the GCL definition.** However, the *design* of a GCL, particularly the duration of guard bands and TSN windows, can be influenced by whether preemption is used in the network. For example, with preemption, guard bands can often be made smaller, leading to more efficient schedules.

**Equivalence between GCLs and Frame Schedules (for Isolated Streams):**

In scenarios where Gate Control Lists (GCLs) are carefully designed to enforce **stream isolation**, a direct correspondence emerges between the GCL configuration and the resulting frame transmission schedule.  This concept of isolation is crucial for achieving deterministic behavior in TSN networks.

*   **Isolated Streams:**  When streams are "isolated," it means that the GCLs are constructed to prevent frames from different time-sensitive streams from interleaving within the same egress port queue.  This can be achieved through techniques like "flow isolation" or "frame isolation" constraints during schedule generation, as discussed in the research paper by Craciunas et al. (2016) [CraciunasRTNS16].

*   **Direct Correspondence:** In such isolated configurations, each TSN window defined in the GCL directly corresponds to the scheduled transmission of specific frames from a dedicated stream (or a group of co-scheduled streams). The timing and duration of the TSN window in the GCL dictate the transmission window for the associated frames in the schedule.  The GCL essentially *enables* and *defines* the permissible transmission times that are reflected in the detailed frame schedule.

*   **Visualization Benefit:** When visualizing GCLs for isolated stream configurations, you are effectively visualizing the *intended schedule* at a higher level of abstraction. The GCL timeline directly represents the planned transmission windows for time-sensitive traffic, making it easier to understand the overall schedule and verify its correctness.

**Important Note:** This direct equivalence is most apparent in carefully engineered TSN configurations aimed at high determinism. In more complex scenarios where complete isolation is not enforced, or where non-TSN traffic significantly influences the network behavior, the correspondence between GCL entries and the frame schedule might be less straightforward. However, even in these cases, GCLs remain the fundamental mechanism for Time-Aware Shaping, and their visualization is essential for understanding the TSN configuration.

**Reference:**

*   Craciunas, S. S., Oliver, R. S., Chmelik, M., & Steiner, W. (2016). Scheduling Real-Time Communication in IEEE 802.1Qbv Time Sensitive Networks. In *Proc. 24th International Conference on Real-Time Networks and Systems (RTNS)*. ACM.

## Switch Configuration (`switch_config.json`)

This file defines the configuration of shapers and queue assignments within the switches. It is assumed that this configuration applies uniformly to all switches in the network across all domains.

```json
{
  "total_queues": 8,
  "queue_assignments": [
    {
      "queue_index": 7,
      "shaper_type": "TAS",
      "PCP_list": [7]
    },
    {
      "queue_index": 6,
      "shaper_type": "TAS",
      "PCP_list": [6]
    },
    {
      "queue_index": 5,
      "shaper_type": "MCQF",
      "PCP_list": [5],
      "params": "bandwidth_fraction=0.3; cycle_length_us=10"
    },
    {
      "queue_index": 4,
      "shaper_type": "MCQF",
      "PCP_list": [5]
    },
    {
      "queue_index": 3,
      "shaper_type": "MCQF",
      "PCP_list": [5]
    },
    {
      "queue_index": 2,
      "shaper_type": "MCQF",
      "PCP_list": [4],
      "params": "bandwidth_fraction=0.3; cycle_length_us=40"
    },
    {
      "queue_index": 1,
      "shaper_type": "MCQF",
      "PCP_list": [4]
    },
    {
      "queue_index": 0,
      "shaper_type": "StrictPriority",
      "PCP_list": [0, 1, 2, 3]
    }
  ]
}
```

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `total_queues` | integer | The total number of physical egress queues available per port on the switches. Queues are indexed from 0 (lowest priority) to total_queues - 1 (highest priority). |
| `queue_assignments` | array | An array of objects, where each object defines the configuration for a specific physical queue index. The array should contain entries for all queues from 0 to total_queues - 1. |
| `queue_index` | integer | The physical queue index (0 to total_queues - 1). |
| `shaper_type` | string | The type of shaper assigned to this queue. Supported values: "TAS" (Time-Aware Shaper), "ATS" (Asynchronous Traffic Shaping), "CBS" (Credit-Based Shaper), "MCQF" (Multi-Queue Credit-Based Shaper), "StrictPriority" (standard strict priority queuing). |
| `PCP_list` | array of integers | A list of PCP values (0-7) that are mapped to this queue and its associated shaper. Streams with these PCPs will use this queue. |
| `params` | string, optional | A string containing shaper-specific parameters. The format depends on shaper_type. Common format is key-value pairs separated by semicolons (e.g., "key1=value1; key2=value2"). |

**Notes on Switch Configuration:**

* **Uniform Configuration:** This configuration applies to all ports of all switches within the network.
* **Queue Indexing:** Queues are indexed from 0 (lowest priority) to total_queues - 1 (highest priority).
* **PCP Mapping:** The PCP_list explicitly defines which stream priorities use which queue. A single queue can handle multiple PCPs.
* **Shaper Combinations:** The format allows defining various combinations by assigning different shaper_type values to different queue_index entries. Supported combinations typically involve TAS at the highest priorities, followed by other shapers (ATS, CBS, MCQF) at lower priorities.
* **Multi-Queue Shaper Parameters (MCQF):** An MCQF shaper operates on a group of queues, typically associated with a single PCP value. The params string containing MCQF parameters should only be specified for the entry corresponding to the highest queue_index within that group. Other queues in the group inherit these parameters.
* **Shaper-Specific Parameters:**
  * For MCQF: Expected format: "bandwidth_fraction=FLOAT; cycle_length_us=INTEGER"
  * For CBS: Expected format: "idle_slope_percent=INTEGER; send_slope_percent=INTEGER"
  * For TAS, ATS, StrictPriority: Currently no specific parameters defined
